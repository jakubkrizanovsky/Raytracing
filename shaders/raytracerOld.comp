#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Sphere {
    vec3 position;
    float radius;
    vec3 color;
};

layout(std140, binding=0) readonly buffer SpheresIn {
    Sphere spheres[];
};

layout(binding = 1, rgba8) uniform image2D outputImage;

#define FLT_MAX 3.402823466e+38

layout(push_constant) uniform PushConsts {
    vec3 camPosition;
    vec3 camForward;
    float camFov;
    vec3 inverseLightDirection;
    vec3 directionalLightColor;
    vec3 ambientLight;
    float diffuseReflectionConstant;
    float specularReflectionConstant;
    float specularExponent;
    uint sphereCount;
    uint width;
    uint height;
} pushConstants;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct RaycastHit {
    bool hit;
    float distance;
    vec3 position;
    vec3 normal;
};

const vec3 UP = vec3(0.0, 1.0, 0.0);
const int MAX_REFLECTIONS = 5;
const float MIN_HIT_DISTANCE = 0.001f;


Ray getCameraRay(ivec2 pixelCoords) {
    vec3 camRight = cross(pushConstants.camForward, UP);
    float gx = -tan(0.5 * pushConstants.camFov);
    float gy = gx * (pushConstants.height - 1.0) / (pushConstants.width - 1.0);
    vec3 qx = 2 * gx / (pushConstants.width - 1) * camRight;
    vec3 qy = 2 * gy / (pushConstants.height - 1) * UP;
    vec3 p1m = pushConstants.camForward - gx * camRight - gy * UP;

    vec3 direction = p1m + qx * pixelCoords.x + qy * pixelCoords.y;

    return Ray(pushConstants.camPosition, direction);
}

RaycastHit raySphereIntersect(Ray ray, Sphere sphere) {
    RaycastHit hit;
    hit.hit = false;

    vec3 positionDelta = sphere.position - ray.origin;

    float a = dot(ray.direction, ray.direction);
    float b = -2.0f * dot(positionDelta, ray.direction);
    float c = dot(positionDelta, positionDelta) - sphere.radius * sphere.radius;

    float determinant = b * b - 4.0f * a * c;

    float x1, x2;
    if (determinant < 0) {
        return hit; // not hit
    } else {
        x1 = (-b - sqrt(determinant)) / (2.0f * a);
        x2 = (-b + sqrt(determinant)) / (2.0f * a);
    }

    if(x1 > MIN_HIT_DISTANCE) {
        hit.distance = x1;
    } else if(x2 > MIN_HIT_DISTANCE) {
        hit.distance = x2;
    } else {
        return hit; // not hit
    }

    hit.hit = true;
    hit.position = ray.origin + ray.direction * hit.distance;
    hit.normal = normalize(hit.position - sphere.position);

    return hit;
}

vec3 specular(Ray ray, RaycastHit hit) {
    vec3 lightReflection = reflect(-pushConstants.inverseLightDirection, hit.normal);

    float phongIntensity = dot(lightReflection, -ray.direction);
    phongIntensity = clamp(phongIntensity, 0.0, 1.0);

    return pushConstants.specularReflectionConstant * pow(phongIntensity, pushConstants.specularExponent) * vec3(1.0);
}

vec3 shadowRay(RaycastHit hit) {
    Ray shadowRay = Ray(hit.position, pushConstants.inverseLightDirection);

    for (int s = 0; s < pushConstants.sphereCount; s++) {
        RaycastHit shadowHit = raySphereIntersect(shadowRay, spheres[s]);
        if (shadowHit.hit) {
            return vec3(0.0);
        }
    }

    float intensity = dot(shadowRay.direction, hit.normal);
    return intensity * pushConstants.directionalLightColor;
}

vec3 raycast(Ray ray) {
    vec3 lightColor = vec3(0.0);
    Ray rays[MAX_REFLECTIONS + 1];
    RaycastHit hits[MAX_REFLECTIONS];
    vec3 hitColors[MAX_REFLECTIONS];
    rays[0] = ray;

    for (int i = 0; i < MAX_REFLECTIONS; i++) { 
        hits[i].hit = false;
        hits[i].distance = FLT_MAX;
        rays[i+1] = rays[i]; // make sure we get no junk values when we don't hit
        for (int s = 0; s < pushConstants.sphereCount; s++) {
            RaycastHit hit = raySphereIntersect(rays[i], spheres[s]);
            if (hit.hit && hit.distance < hits[i].distance) {
                hits[i] = hit;
                hitColors[i] = spheres[s].color;
                rays[i+1].origin = hit.position;
                rays[i+1].direction = reflect(rays[i].direction, hit.normal);
            }
        }
    }

    for (int i = MAX_REFLECTIONS - 1; i >= 0; i--) {
        if (hits[i].hit) {
            float reflectionIntensity = dot(-rays[i].direction, hits[i].normal);
            lightColor *= reflectionIntensity;
            lightColor += pushConstants.ambientLight;
            lightColor += shadowRay(hits[i]);
            lightColor *= hitColors[i];
            lightColor += specular(rays[i], hits[i]);
            lightColor = clamp(lightColor, 0.0, 1.0);
        }
    }

    return lightColor;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

    Ray ray = getCameraRay(pixelCoords);
    vec4 color = vec4(raycast(ray), 1.0);

    imageStore(outputImage, pixelCoords, color);
}
